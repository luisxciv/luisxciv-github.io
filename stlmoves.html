<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Colin James</title>
		<link rel="icon" href="res/img/icon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0" />
		<link rel="stylesheet" type="text/css" href="css/main.css" />
		<link rel="stylesheet" media="screen and (max-width: 490px)" href="css/mobile.css" />
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css" />
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
	</head>

	<body>
		<div id="wrapper">
			<section class="left me">
				<!--TODO: work out how to relative links to work e.g. res/img/avatar.png -->
				<img src="https://avatars2.githubusercontent.com/u/20199633?v=3&u=07ce1d3fa4320278574209c76838f11abfa2c391&s=400" alt="Colin James" class="avatar" />
				<article>
					<h2>Colin James</h2>
					<h3>Software Engineer</h3>
					<nav id="social">
						<ul>
							<li><a href="#"><img src="res/img/fb.svg" alt="My Facebook" /></a></li>
							<li><a href="https://github.com/obscurecolin"><img src="res/img/gh.svg" alt="My GitHub" /></a></li>
							<li><a href="https://twitter.com/_indirection"><img src="res/img/tw.svg" alt="My Twitter" /></a></li>
						</ul>
					</nav>
				</article>
			</section>

			<section class="right" id="content">
			
				<article>
					<pre>@author Colin James</pre>
					<h1 class="title">Tracking STL movement: <span>Static Analysis</span></h1>

<p>In C++, there's the concept of move semantics. Move semantics aim to avoid superfluous copies because, in a world before copy-elision, temporary objects had to be created and then copied to the location where they're consumed. Such consumption is common in implementations using dependency injection or any other place where a transfer of ownership is desired. Such copies are expensive operations and can be considered superfluous since they're copying to a location that consumes them (takes ownership). So, in C++11 and beyond, copy elision is actually guaranteed in certain circumstances. The most typical circumstance would be for the construction of objects returned from factories (which are becoming even more prevalent since the introduction of variadic templates - where you can retain the rvalueness of constructor parameters whilst allowing the compiler to resolve the intended constructor at compile time).</p>
<br />
Most explicit declarations of copy and move constructors are implemented like this:
					<pre>
						<code class="cpp">
class Something {
public:
	Something& Something(const Something &other); // copy ctor
	Something& Something(Something &&other) noexcept; // move ctor
};
						</code>
					</pre>
<p>Often to save them repeating themselves, they often opt for making these constructors invoke relevant copy/move assignment operators.</p>
<p>
However, in cases where such implementations are considered trivial (meaning a class’ members have well-defined copy/move constructor(s)), the compiler can automatically generate their implementations for you implicitly. This is useful as, adhering to one of C++’s main principles, it allows for backwards compatible code to actually be optimised without changing anything (e.g. compiling well-written C++98 code with a C++11 - and onwards - compiler will produce optimisations implicitly). It also have the obvious benefit of saving you from typing out more code than is necessary.
</p>

<p>
The semantics around movement are really just about shallow copying heap allocations from objects you want to move. Thus for POD structs/classes, a move operation will have the exact same overhead as a copy (since you can’t move primitives).</p>
<p>
When people are learning C++'s move semantics, before they have a firm grasp of the rules of special member generation (<i>implicit</i>) and reference collapsing rules, they may opt for writing code that defines explicit copy and move constructors so they can assert that something has actually been moved (usually by piping some output to stdout when the move constructor/assignment is called). Since, otherwise, novice code that looks like it would move something actually doesn’t move anything (usually due to an invalid cast from a const to an rvalue - which retains const correctness and decays to a copy operation - or simply due to a lacking understanding of the aforementioned rules regarding movement; which is all too common in lots of C++ I’ve read).</p>

<p>
So, beginners tend to explicitly declare their copy and move constructors  so they can be assured that the compiler opted for the correct constructor overload (since movement is known at compile time - despite the fact const references can bind to temporaries/rvalues, rvalue references hold a higher precedence for rvalues which allows the compiler to resolve to the correct overload - the move constructor/assignment).</p>

<p>
The fact that compilers are actually aware of movement at compile-time is why I’m suggesting that there should be more static analysis implementations that produce compiler warnings and/or even highlight movement in high level code.</p>
<br />
<p>
An example of unsafe code that isn’t flagged/highlighted by most IDEs’ static analysis tools would be this:</p>
<br />
					<pre>
						<code class="cpp">
class Person {
public:

 // construct with const reference, invoke std::string's copy ctor
 Person(const std::string &name) : name_{name} {} 
 // explicit with rvalue, invoke std::string's move ctor
 Person(std::string &&name) : name_{std::move(name)} {} 

 // accessor
 const std::string &name() const { return name_; }

private:
 std::string name_; // note that std::string is trivially copy/moveable, so special member generation will implicitly generate Person's copy and move ctor
};

int main() {

 std::string name = "Edsger Wybe Dijkstra";

 Person person { std::move(name) }; // move the string (let Person's construction consume it; take ownership of heap-allocated string), thus nullifying it.

 // use of nullified (moved-from) object, should be flagged as invalid
 std::cout << name.length() << '\n'; // outputs 0, of course.

}
						</code>
					</pre>
<p>
However, in the case of STL classes, we can’t simply go in and overload STL copy and move constructors to be notified of their copy and move overloads. It should also be noted that, in the case of std::string, a move constructor can sometimes have the same overhead as a copy constrcutor because if  a string is short enough, its content can be optimised and stored on the stack (thus both a copy and move would require the moved-to object to heap allocate - copy - the contents upon construction). However, we can experiment with tracking STL class movement by writing our own implementation of a <pre class="h">std::allocator</pre>.</p>

<p>
Partially inspired by Howard Hinnant’s <pre class="h">std::allocator</pre> <a href="http://howardhinnant.github.io/allocator_boilerplate.html">boilerplate</a>, I came up with this implementation:
</p>
					<pre>
						<code class="cpp">

template&lt;typename T&gt;
class tracker {
public:

 using value_type = T; // this is actually required, it's also STL convention

 tracker() = default;
 tracker(const tracker &amp;) = default;
 tracker(tracker &amp;&amp;) {
   std::cout &lt;&lt; "Allocator moved\n";
 }

 tracker
 select_on_container_copy_construction() const {
   std::cout &lt;&lt; "Allocator copied\n";
   return *this;
 }

 template&lt;class U&gt;
 tracker(const tracker&lt;U&gt; &amp;) noexcept {}

 value_type *
 allocate(std::size_t n) {
   return static_cast&lt;value_type *&gt;(::operator new(sizeof(value_type) * n));
 }

 void
 deallocate(value_type *p, std::size_t) noexcept {
   delete p;
 }

};

						</code>
					</pre>
<p>
If you’re wondering why <pre class="h">select_on_container_copy_construction</pre> is used, check out the explanation on cppreference: <a href="http://en.cppreference.com/w/cpp/memory/allocator_traits/select_on_container_copy_construction">here</a>. Basically, all STL classes' copy constructors use this.
</p>
<br />
<p>
I then used this custom tracking-allocator in an alias declaration to redefine basic_string’s allocator (<pre class="h">std::string</pre> is a typedef of <pre class="h">std::basic_string&lt;char&gt;</pre>) - seen below. Due to how compilers work for casting template specialisations, I also had to amend the Person class to use my custom type.
</p>

					<pre>
						<code class="cpp">
template&lt;typename T&gt; using basic_tracked_string = std::basic_string&lt;T, std::char_traits&lt;T&gt;, tracker&lt;T&gt;&gt;;

// specialisation to match std::string
using tracked_string = basic_tracked_string&lt;char&gt;;
						</code>
					</pre>
<p>
Now, using this new type, I implemented the same code again and observed the outputs from different compilers:
</p>
<pre>
	<code class="cpp">
tracked_string name = "Edsger Wybe Dijkstra";

Person p { std::move(name) };
std::cout << p.name() << '\n';

std::cout << name.length() << '\n'; // this should be flagged as invalid, outputs 0
	</code>
</pre>

Both clang (4.0.1) and GCC (7.1.1) output the same:

<pre>
	<code class="txt">
Allocator moved
Edsger Wybe Dijkstra
0
	</code>
</pre>
<p>
This is an interesting approach but it’s not as transparent as we’d like (it’s also quite verbose and probably not fully conforming to the traits of <pre class="h">std::allocator</pre>).
Keep in mind you can retain the ability to specialise the STL container’s inner <pre class="h">value_type</pre> whilst using the tracking container as follows with alias declarations:
</p>

<pre>
	<code class="cpp">
template&lt;typename T&gt; using tracked_vector = std::vector&lt;T, tracker&lt;T&gt;&gt;;
	</code>
</pre>

<p>
This is quite interesting since it shows compiler compliance (in previous compiler versions, there were hints that some compilers insert extra copies/moves - still conforming to the standard, just an issue of intent) and fulfils the task of tracking STL copies and moves without having to directly attempt to overload the STL classes’ own copy/move constructor(s) - which, by textbook definition, would be undefined behaviour.
</p>
<p>
As stated before, the resolution involved for selecting a copy/move constructor is done at compile time. This would allow us to create static tooling to detect moves. 
</p>
Going back to the original example where we explicitly cast an lvalue to an rvalue so that Person’s constructor resolves to the rvalue overload that moves the <pre class="h">std::string</pre>, let’s output the AST:


<pre>
	<code class="cpp">
int main() {

 std::string name = "Edsger Wybe Dijkstra";

 Person person { std::move(name) }; // move the string (let Person's construction consume it; take ownership of heap-allocated string), thus nullifying it.

 // use of nullified (moved-from) object, should be flagged as invalid
 std::cout << name.length() << '\n'; // outputs 0, of course.

}
	</code>
</pre>

<strong>
TODO: show AST involving <pre class="h">std::move</pre> (and show how optimisation actually makes such hints somewhat redundant and explain it purely highlights intent; such intent could be used to provide better diagnostic advice)</strong>



			</section>
		</div>
	</body>
</html>
